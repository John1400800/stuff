# Ответы на Вопросы по Алгоритмизации и программированию

## Тема 16: Списки

### 1. Чем отличаются статические и динамические величины?
**Статические величины:**
имеют размер, который устанавливается во время компиляции и не может быть изменен во время выполнения программы. *Например*: массивы фиксированного размера.

**Динамические величины:**
могут изменять свой размер во время выполнения программы. *Например*: списки (`list`) или векторы.

Основное отличие заключается в том, что размер статических величин известен на этапе компиляции, а размер динамических величин может меняться во время работы программы.

Источник:
*   [https://younglinux.info/python/list](https://younglinux.info/python/list)


### 2. Что такое указатель? Что такое ссылка?
**Указатель:**
*   Это переменная, которая хранит адрес в памяти другой переменной.
*   Можно изменять адрес, на который указывает указатель.
*   Может быть `NULL` (не указывать никуда).
*   Для доступа к значению по адресу используется оператор `*` (разыменование).

**Ссылка:**
*   Это псевдоним для другой переменной.
*   Инициализируется при объявлении и не может быть перенаправлена на другую переменную.
*   Не может быть `NULL`.
*   Используется как обычная переменная, и при использовании она автоматически разыменовывается.

Источники:
*   [GeeksforGeeks: Pointers in C](https://www.geeksforgeeks.org/pointers-in-c-cpp/)
*   [GeeksforGeeks: References in C++](https://www.geeksforgeeks.org/references-in-c/)
*   [cppreference.com: References](https://en.cppreference.com/w/cpp/language/reference)


### 3. Какие виды указателей вам известны? 
1.  **Обычные указатели (Data pointers):** Хранят адрес памяти, где располагаются данные определенного типа. Примеры: `int* ptr`, `char* str`.
2.  **Указатели на void (void pointers):** Могут хранить адрес данных любого типа, но требуют приведения типа для разыменования. Пример: `void* ptr`.
3.  **Указатели на функции (Function pointers):** Хранят адрес функции, что позволяет вызывать функцию через указатель. Пример: `int (*func_ptr)(int, int)`.
4.  **Константные указатели (Constant pointers):**
    *   `int* const ptr`: Указатель, который всегда указывает на одно и то же место, но значение по адресу может меняться.
    *   `const int* ptr`: Указатель на константные данные, значение по адресу не может меняться через указатель, но сам указатель может быть перенаправлен.
    *  `const int* const ptr` Указатель, который всегда указывает на одно и то же место, и значение по адресу не может меняться через этот указатель.
5.  **Указатели на указатели (Pointers to pointers):** Хранят адрес другого указателя. Пример: `int** ptr_to_ptr`.
6.  **Умные указатели (Smart pointers):** Это объекты, которые ведут себя как указатели, но автоматически управляют выделением и освобождением памяти (избавляя от утечек памяти). Примеры: `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr` (C++).

Источники:
* [GeeksforGeeks: Types of Pointers](https://www.geeksforgeeks.org/types-of-pointers/)
* [cppreference.com: Smart pointers](https://en.cppreference.com/w/cpp/memory)


### 4. Как определяется адрес переменной?
Адрес переменной определяется с помощью оператора взятия адреса `&`. Он возвращает адрес в памяти, по которому хранится значение переменной.

**Пример (C/C++):**
```c++
int x = 10;
int* ptr = &x; // ptr теперь содержит адрес переменной x
```

В этом примере `&x` возвращает адрес переменной `x`, который затем присваивается указателю `ptr`.

**Примечания:**
*   Оператор `&` можно применить к любой переменной, будь то целое число, символ, массив или объект.
*   Адрес переменной – это уникальный идентификатор её местоположения в оперативной памяти.

Источники:
*  [GeeksforGeeks: Address of Operator (&) in C](https://www.geeksforgeeks.org/address-operator-in-c/)
*  [cppreference.com: Address-of operator](https://en.cppreference.com/w/cpp/language/operator_address)


### 5. Как выделить память под динамическую переменную? Как освободить память от дина-мической переменной?
**Выделение памяти:**
*   C/C++: Используется `malloc()` (или `calloc()`) для выделения и `new` для C++.
*   Java/Python: Память выделяется автоматически при создании объекта/списка.

**Освобождение памяти:**
*   C/C++: Используется `free()` для `malloc`/`calloc` и `delete` (или `delete[]`) для `new`.
*   Java/Python: Сборщик мусора автоматически освобождает неиспользуемую память.

Источники:
*   [GeeksforGeeks: Dynamic Memory Allocation in C](https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/)
*   [Oracle: Garbage Collection](https://docs.oracle.com/javase/tutorial/essential/memory/gc.html)
*   [Python documentation: Memory management](https://docs.python.org/3/c-api/memory.html)


### 6. Что такое "разыменование"?
**Разыменование** – это операция получения значения, хранящегося по адресу, на который указывает указатель. В языках C и C++ для этого используется оператор `*`.

**Пример (C/C++):**
```c++
int x = 10;
int* ptr = &x;  // ptr содержит адрес x
int y = *ptr;   // y теперь равно значению, на которое указывает ptr (т.е. 10)
```

Здесь `*ptr` – это операция разыменования, которая возвращает значение, хранящееся по адресу, на который указывает `ptr`.

**Объяснение:**
*   Указатель хранит адрес в памяти, а не само значение.
*   Оператор `*` позволяет "перейти" по этому адресу и получить значение, которое там хранится.

Источники:
*  [Wikipedia: Indirection (computer science)](https://en.wikipedia.org/wiki/Indirection_(computer_science)#Dereferencing)
*  [GeeksforGeeks: Pointer Dereferencing](https://www.geeksforgeeks.org/pointer-dereferencing-in-c/)


### 7. Какие ситуации приводят к возникновению в динамически распределяемой памяти "мусора"?
**Мусор** в динамически распределяемой памяти возникает, когда выделенная память больше не используется программой, но указатель на неё утерян или не был освобождён, что приводит к утечке памяти.

**Ситуации:**
1.  **Забыли освободить память:** Программист выделил память, но не вызвал `free` (C) или `delete` (C++) для её освобождения после использования.
2.  **Потеряли указатель:** Указатель на выделенную память был перезаписан или вышел из области видимости, и к памяти больше нет доступа, чтобы её освободить.
3.  **Ошибки в логике программы:** Сложная логика выделения и освобождения памяти, где из-за ошибок не все выделения памяти отслеживаются и освобождаются.
4.  **Исключения:** Исключение может помешать нормальному ходу выполнения, и код освобождения памяти не выполнится.

Источники:
*   [Wikipedia: Memory leak](https://en.wikipedia.org/wiki/Memory_leak)
*   [GeeksforGeeks: Memory leaks in C++](https://www.geeksforgeeks.org/memory-leaks-in-c/)


### 8. Что понимают под "связанным списком"? Определение. Графическое представление
**Определение:**
Связанный список (linked list) - это динамическая структура данных, представляющая собой последовательность элементов (узлов), в которой каждый элемент содержит данные и ссылку (указатель) на следующий элемент в последовательности. Последний элемент списка ссылается на `NULL`, обозначая конец списка.

**Графическое представление:**

```
    +-------+      +-------+      +-------+      +-------+
    | data  |  --->| data  |  --->| data  |  --->| data  |  ---> NULL
    | next  |      | next  |      | next  |      | next  |
    +-------+      +-------+      +-------+      +-------+
      node 1         node 2         node 3        node 4
```

**Описание:**
*   **data:**  Поле, хранящее фактические данные узла (например, число, строка, объект).
*   **next:**  Поле, содержащее указатель на следующий узел в списке. Если это последний узел, `next` содержит `NULL`.
*   **node:**  Узел, объединяющий данные и указатель на следующий узел.
*   Стрелки указывают на связь между узлами через указатели `next`.
*   Список обычно имеет "голову" (head), указывающую на первый узел.

**Альтернативное графическое представление:**
```
[Данные1 | Указатель]-->[Данные2 | Указатель]-->[Данные3 | Указатель]-->NULL
   ^
   |
  head
```
Источники:
*  [Wikipedia: Linked list](https://en.wikipedia.org/wiki/Linked_list)
*  [GeeksforGeeks: Linked List Introduction](https://www.geeksforgeeks.org/linked-list-introduction/)


### 9. Как классифицируют связанные списки? 
Связанные списки классифицируют по нескольким критериям:

**1. По направлению связей:**

*   **Односвязные списки (Singly Linked List):** Каждый узел содержит указатель только на следующий узел. Это наиболее простая форма списка.
    ```
    [data | next] --> [data | next] --> [data | next] --> NULL
    ```
*   **Двусвязные списки (Doubly Linked List):** Каждый узел содержит указатели как на следующий, так и на предыдущий узел. Это позволяет перемещаться по списку в обоих направлениях.
    ```
    NULL <--[prev | data | next] <--> [prev | data | next] <--> [prev | data | next] --> NULL
    ```
*   **Многосвязные списки (Multiply Linked List):** Узлы могут иметь несколько указателей на другие узлы, что создаёт более сложные структуры (например, дерево).

**2. По наличию цикличности:**

*   **Линейные списки (Linear Linked List):** Последний узел указывает на `NULL`, то есть список имеет конец. (как в примерах выше)
*   **Кольцевые списки (Circular Linked List):** Последний узел указывает на первый узел, образуя замкнутый цикл.
    ```
     [data | next] --> [data | next] --> [data | next] --> ...
         ^                                               |
         |_______________________________________________|
    ```

**3. По способу организации:**

*   **Неотсортированные списки:** Порядок узлов в списке не зависит от их значений.
*   **Отсортированные списки:** Узлы расположены в порядке возрастания или убывания значения их данных.

**4. По наличию головного (фиктивного) узла:**

*   **Списки с головным узлом:** Список начинается с фиктивного узла, который не содержит полезных данных, а служит для упрощения операций вставки и удаления в начале списка.
*   **Списки без головного узла:** Список начинается с первого узла, содержащего данные.

**Комбинации:**

Эти категории могут комбинироваться, например, "двусвязный кольцевой список", "отсортированный односвязный список", и т.д.

Источники:
*  [GeeksforGeeks: Types of Linked List](https://www.geeksforgeeks.org/types-of-linked-list/)
*  [Tutorialspoint: Data Structures - Linked List](https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithm.htm)


### 10. Какие основные действия над списками и компонентами списков обычно реализуют?
Над списками и их компонентами обычно реализуют следующие основные действия:

**1. Создание списка:**

*   **Инициализация:** Создание пустого списка (обычно, установка "головы" списка в `NULL` или на головной фиктивный узел).
*   **Создание узла:** Выделение памяти под новый узел и установка его данных.

**2. Добавление элемента:**

*   **В начало:** Вставка нового узла в начало списка, перед текущим головным узлом (или после фиктивного головного узла).
*   **В конец:** Вставка нового узла в конец списка (требует прохода по списку для поиска последнего узла).
*   **В середину:** Вставка нового узла после или перед указанным узлом (требует поиска позиции вставки).
*    **Вставка в отсортированный список:** Вставка нового узла в правильную позицию, чтобы сохранить сортировку списка.

**3. Удаление элемента:**

*   **Из начала:** Удаление головного узла списка.
*   **Из конца:** Удаление последнего узла списка (требует прохода по списку для поиска предпоследнего узла).
*   **Из середины:** Удаление указанного узла (требует поиска удаляемого узла и корректировки ссылок).
*  **Удаление по значению:** Удаление узла с заданным значением (требует поиска).

**4. Поиск элемента:**

*   **По значению:** Поиск узла, содержащего заданное значение.
*   **По индексу (в некоторых реализациях):** Поиск узла по его порядковому номеру в списке.

**5. Просмотр/Обход списка:**

*   **Перебор всех узлов:** Последовательное посещение каждого узла списка для обработки данных (печать, обновление, подсчет и т.д.).
*  **Обход в прямом и обратном порядке (для двусвязных):** Для двусвязных списков есть возможность обхода в обоих направлениях.

**6. Другие операции:**

*   **Получение длины:** Определение количества узлов в списке.
*   **Очистка списка:** Удаление всех узлов и освобождение занимаемой ими памяти.
*   **Разворот списка:** Изменение порядка элементов списка на обратный.
*  **Слияние списков:** Создание нового списка путем объединения двух или более существующих.
*   **Сортировка списка:** Сортировка элементов списка по заданному критерию.

**Компоненты списков (узлы):**

*   **Доступ к данным:** Чтение и изменение данных, хранящихся в узле.
*   **Доступ к указателю на следующий/предыдущий узел:** Изменение этих указателей.
*    **Создание и удаление:** Выделение и освобождение памяти под узел.

Источники:
*  [GeeksforGeeks: Basic operations on Linked list](https://www.geeksforgeeks.org/basic-operations-on-linked-list/)
*  [Tutorialspoint: Data Structures - Linked List](https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithm.htm)


### 11. Как описывается список?
В C++ список (связанный список) обычно описывается с использованием структур или классов для представления узла и отдельного класса для самого списка, который управляет узлами.

**1. Описание узла (Node):**

```cpp
struct Node {
    int data;  // Данные, хранящиеся в узле (можно использовать любой тип данных)
    Node* next; // Указатель на следующий узел

    // Конструктор (опционально)
    Node(int val) : data(val), next(nullptr) {}
};
```
**2. Описание односвязного списка (Singly Linked List):**
```cpp
class LinkedList {
private:
    Node* head; // Указатель на первый узел списка

public:
    // Конструктор
    LinkedList() : head(nullptr) {}

    // Методы для работы со списком
    void insertAtBeginning(int value); // Добавление в начало
    void insertAtEnd(int value); // Добавление в конец
    void insertAfter(Node* prev_node, int value); // Добавление после узла
    void deleteNode(int value);  // Удаление узла по значению
    void printList(); // Печать списка
    // Добавьте другие необходимые методы, как поиск, удаление, очистка и т.д.
    ~LinkedList(); // Деструктор
};
```
**3. Пример реализации методов:**
```cpp
void LinkedList::insertAtBeginning(int value) {
    Node* newNode = new Node(value);
    newNode->next = head;
    head = newNode;
}

void LinkedList::insertAtEnd(int value){
    Node* newNode = new Node(value);
    if(head == nullptr){
        head = newNode;
        return;
    }
    Node* current = head;
    while(current->next != nullptr){
        current = current->next;
    }
    current->next = newNode;
}
void LinkedList::deleteNode(int value){
    if (head == nullptr) {
        return; // Список пуст
    }
    if(head->data == value){
        Node* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    Node* current = head;
    Node* prev = nullptr;
    while(current != nullptr && current->data != value){
        prev = current;
        current = current->next;
    }
    if(current == nullptr) return; //Элемент не найден

    prev->next = current->next;
    delete current;

}
void LinkedList::printList(){
    Node* current = head;
    while(current != nullptr){
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;
}

LinkedList::~LinkedList() {
    Node* current = head;
    while(current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
}
```

**4. Пример использования:**

```cpp
int main() {
    LinkedList myList;
    myList.insertAtBeginning(5);
    myList.insertAtBeginning(1);
    myList.insertAtEnd(10);
    myList.printList(); // 1 5 10
    myList.deleteNode(5);
    myList.printList(); // 1 10

    return 0;
}
```
**Описание:**
*   **Node:**  структура, представляющая узел списка, содержит данные `data` и указатель `next` на следующий узел.
*   **LinkedList:** класс, инкапсулирующий список, содержит указатель `head` на первый узел и методы для работы со списком.
*  Деструктор для освобождения памяти, занятой списком.

Источники:
*   [GeeksforGeeks: Linked List Implementation in C++](https://www.geeksforgeeks.org/linked-list-implementation-in-c-plus-plus/)
*   [cppreference.com](https://en.cppreference.com/w/cpp)


### 12. Понятие стека, очереди.
**Стек:**

Стек - это структура данных LIFO (Last In, First Out - "последним пришел, первым ушел"). Представьте стопку книг: вы кладете книгу сверху и берете тоже сверху. Операции происходят только с одного конца - вершины:
*   `push`: Добавляет элемент на вершину.
*   `pop`: Удаляет и возвращает элемент с вершины.
*   `peek` (или `top`): Возвращает элемент с вершины, не удаляя.
*   `isEmpty`: Проверяет, пуст ли стек.

Стеки используются для вызовов функций, отмены действий, синтаксического анализа и обхода дерева в глубину.

**Очередь:**

Очередь - это структура данных FIFO (First In, First Out - "первым пришел, первым ушел"). Представьте очередь в магазине: первый в очереди обслуживается первым. Элементы добавляются в конец и удаляются с начала:
*   `enqueue`: Добавляет элемент в конец очереди.
*   `dequeue`: Удаляет и возвращает элемент из начала очереди.
*   `peek` (или `front`): Возвращает элемент из начала, не удаляя.
*   `isEmpty`: Проверяет, пуста ли очередь.

Очереди используются в планировании задач, буферизации данных, моделировании очередей и обходе дерева в ширину.

Источники:
*   [GeeksforGeeks: Stack Data Structure](https://www.geeksforgeeks.org/stack-data-structure/)
*   [GeeksforGeeks: Queue Data Structure](https://www.geeksforgeeks.org/queue-data-structure/)
*   [Wikipedia: Stack (abstract data type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
*   [Wikipedia: Queue (abstract data type)](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))


### 13. Типовые операции, выполняемые над стеком.
**Типовые операции над стеком:**

Стек – это структура данных LIFO (Last In, First Out), где добавление и удаление элементов происходят с одного конца, называемого вершиной. Вот типовые операции, выполняемые над стеком:

1.  **push(element):** Добавляет элемент на вершину стека.
    *   Если стек полон, происходит переполнение (stack overflow).

2.  **pop():** Удаляет и возвращает элемент с вершины стека.
    *   Если стек пуст, происходит опустошение (stack underflow).

3.  **peek() или top():** Возвращает элемент с вершины стека, не удаляя его.
    *   Если стек пуст, результат не определен (может вернуть ошибку).

4.  **isEmpty():** Проверяет, пуст ли стек.
    *   Возвращает `true`, если стек пуст, и `false` в противном случае.

5.  **isFull():** Проверяет, полон ли стек (если стек имеет ограниченный размер).
    *    Возвращает `true`, если стек полон, и `false` в противном случае.

6. **size():** Возвращает количество элементов в стеке.
7.  **clear():** Удаляет все элементы из стека, делая его пустым.

**Графическое представление:**

```
    +-----+    push(D)   +-----+
    |  C  |  <-------    |  D  |  <-- top
    +-----+              +-----+
    |  B  |              |  C  |
    +-----+              +-----+
    |  A  |              |  B  |
    +-----+              +-----+
                         |  A  |
                         +-----+
```
```
    +-----+       pop()  +-----+
    |  D  |  <-------    |  C  |  <-- top (возвращает D)
    +-----+              +-----+
    |  C  |              |  B  |
    +-----+              +-----+
    |  B  |              |  A  |
    +-----+              +-----+
    |  A  |
    +-----+
```
Источники:
*   [GeeksforGeeks: Stack Data Structure](https://www.geeksforgeeks.org/stack-data-structure/)
*   [Tutorialspoint: Stack Operations](https://www.tutorialspoint.com/data_structures_algorithms/stack_algorithm.htm)


### 14. Типовые операции, выполняемые над очередью.
**Типовые операции над очередью:**

Очередь – это структура данных FIFO (First In, First Out), где добавление элементов происходит в конец (rear), а удаление – с начала (front). Вот основные операции:

1.  **enqueue(element):** Добавляет элемент в конец очереди.
    *   Если очередь полна, происходит переполнение.

2.  **dequeue():** Удаляет и возвращает элемент из начала очереди.
    *   Если очередь пуста, происходит опустошение.

3.  **peek() или front():** Возвращает элемент из начала очереди, не удаляя его.
     *   Если очередь пуста, результат не определен.

4.  **isEmpty():** Проверяет, пуста ли очередь.
     *   Возвращает `true`, если очередь пуста, и `false` в противном случае.

5.  **isFull():** Проверяет, полна ли очередь (если очередь имеет ограниченный размер).
    *    Возвращает `true`, если очередь полна, и `false` в противном случае.
6.  **size():** Возвращает количество элементов в очереди.

7.  **clear():** Удаляет все элементы из очереди, делая ее пустой.

**Графическое представление:**

```
     front       rear
      ↓           ↓
    +-----+-----+-----+    enqueue(D)     +-----+-----+-----+-----+
    |  A  |  B  |  C  |  <----------      |  A  |  B  |  C  |  D  |
    +-----+-----+-----+                   +-----+-----+-----+-----+
```
```
        front             rear              front                rear
         ↓                 ↓                 ↓                     ↓
    +-----+-----+-----+-----+      dequeue()   +-----+-----+-----+
    |  A  |  B  |  C  |  D  |    ---------->   |  B  |  C  |  D  |
    +-----+-----+-----+-----+                  +-----+-----+-----+
                                   (возвращает A)
```
Источники:
*   [GeeksforGeeks: Queue Data Structure](https://www.geeksforgeeks.org/queue-data-structure/)
*   [Tutorialspoint: Queue Operations](https://www.tutorialspoint.com/data_structures_algorithms/queue_algorithm.htm)



## Тема 17: Деревья

### 1. Что такое дерево?
**Дерево (в контексте структур данных):**

Дерево - это иерархическая структура данных, состоящая из узлов (nodes), соединенных ребрами (edges). Оно представляет собой связный ациклический граф, где:

*   Есть один специальный узел, называемый **корнем (root)**, который находится на вершине иерархии.
*   Каждый узел, кроме корня, имеет ровно одного **родителя (parent)**.
*   Узел может иметь **потомков (children)**, которые являются узлами, соединенными с ним ребром.
*   Узлы, не имеющие потомков, называются **листьями (leaves)** или конечными узлами.
*   **Глубина (depth)** узла — это количество ребер от корня до этого узла.
*   **Высота (height)** дерева — это максимальная глубина любого узла в дереве.

**Основные понятия:**

*   **Узел (Node):** Элемент дерева, содержащий данные и ссылки на других узлов.
*   **Ребро (Edge):** Связь между двумя узлами.
*   **Родитель (Parent):** Узел, который имеет потомков.
*   **Потомок (Child):** Узел, соединенный ребром с родительским узлом.
*   **Лист (Leaf):** Узел без потомков.
*   **Поддерево (Subtree):** Дерево, состоящее из узла и всех его потомков.
*   **Уровень (Level):** Все узлы на одинаковом расстоянии от корня.

**Графическое представление:**

```
        A (корень)
       / \
      /   \
     B     C
    / \   / \
   D   E  F  G
```

В этом примере:
*   `A` - корень.
*   `B` и `C` - дети `A`.
*   `D` и `E` - дети `B`.
*   `F` и `G` - дети `C`.
*   `D`, `E`, `F`, `G` - листья.

Деревья применяются для представления иерархических данных, таких как файловые системы, организационные структуры, иерархии классов в объектно-ориентированном программировании, а также в алгоритмах поиска и сортировки.

Источники:
*   [GeeksforGeeks: Tree Data Structure](https://www.geeksforgeeks.org/tree-data-structure/)
*  [Wikipedia: Tree (data structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))


### 1. Классификация деревьев.
**Дерево (в контексте структур данных):**

Дерево - это иерархическая структура данных, состоящая из узлов (nodes), соединенных ребрами (edges). Оно представляет собой связный ациклический граф, где:

*   Есть один специальный узел, называемый **корнем (root)**, который находится на вершине иерархии.
*   Каждый узел, кроме корня, имеет ровно одного **родителя (parent)**.
*   Узел может иметь **потомков (children)**, которые являются узлами, соединенными с ним ребром.
*   Узлы, не имеющие потомков, называются **листьями (leaves)** или конечными узлами.
*   **Глубина (depth)** узла — это количество ребер от корня до этого узла.
*   **Высота (height)** дерева — это максимальная глубина любого узла в дереве.

**Основные понятия:**

*   **Узел (Node):** Элемент дерева, содержащий данные и ссылки на других узлов.
*   **Ребро (Edge):** Связь между двумя узлами.
*   **Родитель (Parent):** Узел, который имеет потомков.
*   **Потомок (Child):** Узел, соединенный ребром с родительским узлом.
*   **Лист (Leaf):** Узел без потомков.
*   **Поддерево (Subtree):** Дерево, состоящее из узла и всех его потомков.
*   **Уровень (Level):** Все узлы на одинаковом расстоянии от корня.

**Графическое представление:**

```
        A (корень)
       / \
      /   \
     B     C
    / \   / \
   D   E  F  G
```

В этом примере:
*   `A` - корень.
*   `B` и `C` - дети `A`.
*   `D` и `E` - дети `B`.
*   `F` и `G` - дети `C`.
*   `D`, `E`, `F`, `G` - листья.

Деревья применяются для представления иерархических данных, таких как файловые системы, организационные структуры, иерархии классов в объектно-ориентированном программировании, а также в алгоритмах поиска и сортировки.

Источники:
*   [GeeksforGeeks: Tree Data Structure](https://www.geeksforgeeks.org/tree-data-structure/)
*  [Wikipedia: Tree (data structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))

