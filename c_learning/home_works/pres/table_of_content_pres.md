# Story outline

### Слайд 1: "Модули в C++20"

Добро пожаловать на презентацию о модулях в C++20! Сегодня мы рассмотрим, что
такое модули, зачем они нужны и как они помогают улучшить разработку на C++.

---

### Слайд 2: "Введение"

Сначала давайте поговорим о том, зачем нужны заголовочные файлы. В большинстве
проектов на C++ используется несколько единиц трансляции. Заголовочные файлы
помогают делиться объявлениями и определениями между этими единицами.

Однако у заголовочных файлов есть свои минусы. Например, они могут вызывать
избыточную компиляцию, сложные зависимости, и не позволяют строго
контролировать, что именно импортируется. Команда `#include` просто вставляет
содержимое файла в код, что может быть неудобно.

Модули решают эти проблемы, предоставляя более современный и эффективный способ
обмена объявлениями и определениями.

---

### Слайд 3: "Пример использования заголовочных файлов"

На этом слайде показан пример использования заголовочных файлов. Мы видим, как
создаются отдельные файлы для функций и как они подключаются через `#include` в
`main.cpp`. Это стандартный способ работы в C++, но он имеет свои ограничения,
которые мы обсудим далее.

---

### Слайд 4: "#include нельзя контролировать"

Проблема с `#include` в том, что он буквально вставляет содержимое
заголовочного файла в код. Это позволяет делать странные и неочевидные вещи,
которые могут привести к ошибкам или запутанному коду. Пример на этом слайде
показывает, как можно вставить целую строку с помощью `#include` — и это не
вызовет ошибок, хотя такой подход совершенно не рекомендуется.

---

### Слайд 5: "Нельзя включать файлы дважды"

Еще одна проблема с заголовочными файлами — невозможность включать их несколько
раз без специальной защиты, например, `#pragma once` или защитных макросов. Без
этих мер включение одного и того же файла дважды приведет к ошибкам компиляции.

---

### Слайд 6: "Файл может использовать не определенные в нем вещи"

В заголовочных файлах нет строгой привязки к зависимостям. Например, в классе
`Person` на слайде используется `std::string`, но этот тип не объявлен в самом
заголовке. Это может работать только при условии, что нужные заголовки
подключены в других местах.

---

### Слайд 7: "Пример использования модулей"

Теперь давайте посмотрим, как можно использовать модули. Модули обеспечивают
четкое разделение кода. Вместо `#include` используется ключевое слово `import`,
а функции и классы, которые нужно сделать доступными, экспортируются с помощью
`export`. Такой подход упрощает управление зависимостями.

---

### Слайд 8: "Сравнение компиляции модулей и заголовочных файлов"

На этом слайде показано, как использование модулей значительно сокращает объем
работы, выполняемой препроцессором. Код становится более компактным и понятным,
что особенно важно в крупных проектах.

---

### Слайд 9: "Сравнение времени компиляции"

Также модули ускоряют компиляцию. На слайде приведены конкретные цифры,
показывающие, насколько быстрее компиляция происходит при использовании модулей
вместо заголовочных файлов.

---

### Слайд 10: "Более подробно о export"

Ключевое слово `export` позволяет точно контролировать, какие функции, классы и
шаблоны будут доступны из модуля. Это дает большую гибкость в управлении кодом
и улучшает инкапсуляцию.

---

### Слайд 11: "Разделение модулей на разделы"

Модули можно разделять на разделы, чтобы еще больше упростить управление
крупными проектами. Это особенно полезно, если проект состоит из большого
количества связанных между собой частей.

---

### Слайд 12: "Простой пример использования модулей"

Здесь представлен пример модуля `Person` и его использования. Модуль делится на
интерфейс и реализацию, что облегчает читаемость и модификацию кода. Реализация
скрыта, а интерфейс четко определен.

---

### Слайд 13: "И то же самое с использованием заголовочных файлов"

Для сравнения показано, как тот же код реализуется с помощью заголовочных
файлов. Здесь требуется больше усилий для управления зависимостями и
структурами, что увеличивает сложность разработки.

---

### Слайд 14: "Различия во времени компиляции"

Этот слайд показывает, что модули особенно эффективны при многократной
компиляции. Заголовочные файлы требуют больше времени из-за работы
препроцессора, а модули минимизируют эти затраты.

---

### Слайд 15: "Можно использовать заголовочные файлы вместе с модулями"

Иногда может понадобиться комбинировать модули и заголовочные файлы. Например,
если нужно работать с макросами или библиотеками, которые еще не поддерживают
модули. Это гибкий подход, позволяющий использовать преимущества обоих методов.

---

### Слайд 16: "Итоги"

В заключение:
- Модули решают проблемы избыточной компиляции и зависимостей.
- Они ускоряют сборку проектов, особенно при многократной компиляции.
- Модули поддерживают явный экспорт, что улучшает управление видимостью
  символов.
- Они идеально подходят для крупных проектов.

Однако стоит учитывать, что не все инструменты и IDE пока поддерживают модули.
Поэтому их использование нужно адаптировать к конкретному проекту.

